# Functional-Light JavaScript
# Chapter 8: Recursion

Рекурсия - один из тех методов программирования, которые большинство разработчиков признают очень мощным, но большинство из них не любят его использовать. В этом смысле я бы поставил его в ту же категорию, что и регулярные выражения. Мощный, но непонятный, и, следовательно, он не стоит усилий.

Я большой поклонник рекурсии, и вы тоже можете стать ими! К сожалению, многие примеры рекурсии сосредоточены на тривиальных академических задачах, таких как генерация последовательностей Фибоначчи. Если вам нужны эти числа в вашей программе - и давайте посмотрим правде в глаза, это не очень распространено! - вы, скорее всего, пропустите общее представление.

На самом деле, рекурсия является одним из наиболее важных способов, с помощью которых разработчики избегают обязательного цикла и переназначения, перекладывая детали реализации на язык и движок. При правильном использовании рекурсия обеспечивает декларативный стиль для сложных задач.

К сожалению, рекурсия уделяет гораздо меньше внимания, особенно в JS, чем должна, в значительной степени, из-за оограничений производительности (скорости и памяти). Наша цель в этой главе - копнуть глубже и найти практические причины, по которым рекурсия должна быть в центре нашей функциональной разработки.

## Определение

Рекурсия - это когда функция вызывает саму себя, каждый вызов делает одно и тоже. Этот цикл продолжается пока не будет достигнуто базовое условие, тогда цикл прекращается.

**Внимание_:** Если вы не гарантируете, что базовое условие будет в конечном итоге удовлетворено, рекурсия будет выполняться вечно, и "положит" вашу программу. Базовое условие необходимо для корректной работы рекурсии.

Но... это определение слишком запутанно! Мы можем сделать его лучше. Для этого рассмотрим рекурсивную функцию:

```javascript
function foo(x) {
    if (x < 5) return x;
    return foo( x / 2 );
}
```

Давайте визуализируем работу этой функции на примере  `foo(16)`:
[!process](https://github.com/getify/Functional-Light-JS/blob/master/manuscript/images/fig13.png)

На шаге 2 `x / 2` вернется 8 и передатся, как аргумент в рекурсивный вызов `foo(...)`. На шаге 3 та же самая операция `x / 2` вернет нам 4 и передаст ее в еще один рекурсивный вызов `foo()`. Эта часть, надеюсь, довольно проста.

 Момент, где кто-то часто может споткнуться, это то, что происходит на шаге 4. Как только будет выполнено базовое условие, `x` (со значанием 4) `< 5`, рекурсывные вызовы прекратятся и на вернется 4. Пунктирная линия на рисунке более явно изображает этот процесс. Что ж, давайте копнем поглубже и изобразим этот процесс еще более подробно:

[!process](https://raw.githubusercontent.com/getify/Functional-Light-JS/master/manuscript/images/fig14.png)

**После того, как базовое условие выполнено, возвращаемое значение каскадирует все текущие вызовы функций**

Другим способом визуализации этой рекурсии является рассмотрение вызовов функций в том порядке, в котором они происходят (обычно это называют "стек вызова"):

[!callStack](https://raw.githubusercontent.com/getify/Functional-Light-JS/master/manuscript/images/fig19.png)

Мы подробнее изучим стек вызовоа позже в этой главе.

Другой пример рекурсии:

```javascript
function isPrime(num,divisor = 2){
    if (num < 2 || (num > 2 && num % divisor == 0)) {
        return false;
    }
    if (divisor <= Math.sqrt( num )) {
        return isPrime( num, divisor + 1 );
    }

    return true;
}
```

Эта проверка на простое число работает так: **This prime checking basically works by trying each integer from 2 up to the square root of the num being checked, to see if any of them divide evenly (% mod returning 0) into the number. If any do, it's not a prime. Otherwise, it must be prime. The divisor + 1 uses the recursion to iterate through each possible divisor value.**

Один из самых знаменитых примеров рекурсии - это вычисление чисел Фибоначчи, где последовательность определяется как:

```javascript
fib( 0 ): 0
fib( 1 ): 1
fib( n ):
    fib( n - 2 ) + fib( n - 1 )
```

**Примечание:** первые несколько чисел этой последовательности: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ... Каждое число является результатом сложения двух предыдущих

Определение Чисел Фибоначчи в коде выражается так:

```javascript
function fib(n) {
    if (n <= 1) return n;
    return fib( n - 2 ) + fib( n - 1 );
}
```

`fib(...)` рекурсивно вызывает себя дважды, что часто называют "бинарной рекурсией". Мы поговорим о бинарной рекурсии позже.

Мы будем использовать `fib()` по-разному в этой главе, для описания идей рекурсии. У конретно этой формы использования есть недостаток, заключающийся в дублировании работы. **fib(n-1) and fib(n-2) don't share any of their work with each other, but overlap with each other almost entirely, over the entire integer space down to 0.**

Мы кратко касались мемоизации в Главе 5. Здесь мемоизация позволит вычислять последовательность Фибоначчи для любого заданного числа только один раз, вместе нового вычисления каждый раз. Мы не будем вдаваться в эту тему здесь, но этот такт о производительности важно иметь в виду с любым алгоритмом, рекурсивным или нет.

### Взаимная рекурсия

Когда функция вызывает себя, в частности, это называется прямой рекурсией. Мы видели в предыдущем разеделе: `foo()`, `isPrime()`, `fib()`. Когда две и более фунцкции вызывают друг друга в рекурсивом цикле, то это называется взаимной рекурсией.

Эти две функции взаимно рекурсивные:

```javascript
function isOdd(v) {
    if (v === 0) return false;
    return isEven( Math.abs( v ) - 1 );
}

function isEven(v) {
    if (v === 0) return true;
    return isOdd( Math.abs( v ) - 1 );
}
```

Да, конечно это дурацкий способ выяснить четность/нечетность числа. Но он иллюстрирует идею о том, что определенные алгоритмы могут быть определены с точки зрения взаимной рекурсии.

Выразим бинарную рекурсию `fib()` из прошлой главы, в виде взаимой рекурсии:

```javascript
function fib_(n) {
    if (n == 1) return 1;
    else return fib( n - 2 );
}

function fib(n) {
    if (n == 0) return 0;
    else return fib( n - 1 ) + fib_( n );
}
```

**Примечание:** Эта реализация взаминой рекурсии вдохновлена исследованием из статьи ["Fibonacci Numbers Using Mutual Recursion"](https://www.researchgate.net/publication/246180510_Fibonacci_Numbers_Using_Mutual_Recursion)

Пока что все примеры взаимной рекурсии "притянуты за уши", существует гораздо более сложные кейсы, где взаимная рекурсия может оказаться очень полезной. Один из таких кейсов: подсчет числа "листьев" в древовидных структурах данных. Другой кейс: метод рекурсивного спуска.


#### Почему рекурсия?

Теперь, когда мы определили и проиллюстрировали рекурсию, пора расскзать, как она может быть полезна.

Наиболее часто упоминаемая причина, по которой рекурсия соответствует духу FP, заключается в том, что она **ВЗАИМОДЕЙСТВУЕТ** (большую часть) явное отслеживание состояния с неявным состоянием в стеке вызовов. Как правило, рекурсия наиболее полезна, когда проблема требует условного разветвления и обратного отслеживания, а управление этим видом состояния в чисто итеративной среде может быть довольно сложным; как минимум, код крайне императивный и сложнее читать и проверять. Но отслеживание каждого уровня ветвления как своего собственного скоупа в стеке вызовов часто значительно улучшает читаемость кода.

Простые итеративные алгоритмы можно тривиально выразить как рекурсию:

```javascript
function sum(total,...nums) {
    for (let num of nums) {
        total = total + num;
    }

    return total;
}

// против

function sum(num1,...nums) {
    if (nums.length == 0) return num1;
    return num1 + sum( ...nums );
}
```

Дело не только в том, что for-loop устраняется в пользу стека вызовов, но что инкрементные частичные суммы (прерывистое состояние общего) отслеживаются неявно через `return`ы стека вызовов вместо того, чтобы переопределять `total` каждую итерацию. Адепты функционального программирования предпочитают избегать переорпедления локальных переменных там, где это возможно.

В базовом алгоритме, таком как суммирование, это различие незначительно и тонко. Но чем сложнее ваш алгоритм, тем больше вы, скорее всего, увидите преимущество рекурсии вместо обязательного отслеживания состояния.

### Декларативная рекурсия

Математики используют символ Σ в качестве представления суммирования списка чисел. Основная причина, по которой они это делают, заключается в том, что она более громоздка (и менее читаема!), если они работают с более сложными формулами, и им приходится записывать суммирование вручную, например `1 + 3 + 5 + 7 + 9 + ..` Использование обозначений - декларативная математика!

Рекурсия является декларативным обозначением для алгоритмов в том же смысле, что и Σ является декларативным обозначением для математики. Рекурсия показывает, что существует решение проблемы, но не обязательно требует, чтобы тот, кто читает код понял, как это решение работает.
Рассмотрим два подхода к поиску наивысшего четного числа, переданного в качестве аргумента:

```javascript
function maxEven(...nums) {
    var maxNum = -Infinity;

    for (let num of nums) {
        if (num % 2 == 0 && num > maxNum) {
            maxNum = num;
        }
    }

    if (maxNum !== -Infinity) {
        return maxNum;
    }
}
```

Этот подход не особенно сложен, но и некотрые его нюансы не особенно очевидны. Насколько очевидно, что вызовы `maxEven()`, `maxEven(1)`и `maxEven(1,13)` вернут `undefined`? Сразу ли понятно, почему необходимо окончательный `if`?

Давайте вместо этого рассмотрим рекурсивный подход, для сравнения. Мы можем обозначить рекурсию таким образом:

```javascript
maxEven( nums ):
    maxEven( nums.0, maxEven( ...nums.1 ) )
```

Другими словами, мы можем определить максимальную четность списка чисел, как максимальную четность первого числа по сравнению с максимальной четностью остальных чисел. Например:

<!-- ```javascript
maxEven( 1, 10, 3, 2 ):
    maxEven( 1, maxEven( 10, maxEven( 3, maxEven( 2 ) ) )
``` -->

Вот один из способов реализовать такое поведение в JS

```javascript
function maxEven(num1,...restNums) {
    var maxRest = restNums.length > 0 ?
            maxEven( ...restNums ) :
            undefined;

    return (num1 % 2 != 0 || num1 < maxRest) ?
        maxRest :
        num1;
}
```

Итак, какие преимущества имеет этот подход?

Во-первых, сейчас сигнатура немного иная. Я намеренно назвал `num1`, как имя первого аргумента, собирающего остальные в `restNums`. Но зачем? Мы могли бы просто собрать их всех в один массив `nums` и затем обратиться к `nums[0]`.

Эта сигнатура функции является преднамеренным намеком на рекурсию. Она читается следующим образом:

```javascript
maxEven( num1, ...restNums ):
    maxEven( num1, maxEven( ...restNums ) )
```

Вы видите симметрию между сигнатурой и рекурсивным определением?

**НЕ забыть про определение сигнатуры**
Когда мы можем сделать рекурсивное определение более очевидным даже в сигнатуре функции, мы улучшаем декларативность функции. И если мы сможем затем отразить рекурсивное определение от сигнатуры к телу функции, оно станет еще лучше.

**Но я бы сказал, что наиболее очевидным улучшением является то, что отвлечение императива для петли подавляется**. Вся логика цикла абстрагируется в рекурсивный стек вызова, так что это не загромождает код. Теперь мы можем сосредоточиться на логике нахождения максимума даже при сравнении двух чисел за раз - важная часть в любом случае!

То, что происходит, похоже на то, когда математик использует суммирование Σ в более крупном уравнении. **Мы говорим: «максимальная часть остальной части списка вычисляется maxEven (... restNums), поэтому мы просто примем эту часть и перейдем».**

Кроме того, мы усиливаем наше решение с помощью `restNums.length > 0`, потому что, если нет больше чисел для рассмотрения, то результат `maxRest` будет `undefined`. Нам не нужно уделять какое-либо дополнительное внимание на эту часть рассуждений. Это базовое условие (больше нет чисел для рассмотрения) совершенно очевидно.

Далее обратим внимание на проверку `num1 < maxRest` - тут основная логика заключается в способе определения, какой из двух чисел максимальное-четное. Если `num1` нечетное (`num1 % 2 != 0`) меньше, чем `maxRest`, то вернется `maxRest`, даже, если оно `undefined`. В противном случау вернется `num1`.

Разобранный случай, показывает, что эта реализации более ясна (меньше нюансов), чем императивная реализация с использованием `for` и `-Infinity`.

**Совет**: Мы должны указать, что другой (скорее всего, лучший!) cпособ решить эту задачу, кроме итерации или рекурсии, это использование методов работы со списками, `filter(...)`, чтобы найти все четные числа и `reduce(...)`, чтобы найти среди них максимальное. Мы только использовали этот пример, чтобы проиллюстрировать более декларативный характер рекурсии по сравнению с итерацией.

#### Binary Tree Recursion

Другой пример использования рекурсии: вычисление глубины бинарного дерева. Почти каждая операция, которую вы будете делать с деревьями, наиболее легко реализуется с рекурсией, поскольку ручное отслеживание стека вверх и вниз **крайне императивно и подвержено ошибкам**.

Глубина бинарного дерева - это самый длинный путь (либо с левой либо с правой) вниз по узлам дерева. Или иными словами - глубина дерева на любом узле равно 1 плюс _бОльшая_ из глубин дочерних деревьев (левого или правого).

```javascript
depth( node ):
    1 + max( depth( node.left ), depth( node.right ) )
```

Переведем сигнатуру в функцию:

```javascript
function depth(node) {
    if (node) {
        let depthLeft = depth( node.left );
        let depthRight = depth( node.right );
        return 1 + max( depthLeft, depthRight );
    }

    return 0;
}
```

Я не буду показывать императивную форму этого алгоритма, но поверьте мне, это намного "жестче". Этот рекурсивный подход является красивым и изящно декларативным. Он соответсвтует рекурсивному определению алгоритма практический полностью, лишь с небоьшими отклонениями.

Не все проблемы легко решаются рекурсией. Это не серебряная пуля, которую вы должны стараться применять повсюду. Но рекурсия может быть очень эффективной при преобразовании выражение от более императивного к более декларативному.

### Стэк

Вернемся к `isOdd(..)`/`isEven(..)`:

```javascript
function isOdd(v) {
    if (v === 0) return false;
    return isEven( Math.abs( v ) - 1 );
}

function isEven(v) {
    if (v === 0) return true;
    return isOdd( Math.abs( v ) - 1 );
}
```

В большинстве браузеров, если вы попытаетесь вызвать фуннцию с таким аргументом, то получите ошибку:

```javascript
isOdd( 33333 );         // RangeError: Maximum call stack size exceeded
```

Что происходит? Движок выбратсывает эту ошибку, предотвращая переполнение памяти. Чтобы разобраться подробнее нужно заглянуть под капот движка в тот момент, когда происходит вызов функции.

Каждый вызов функции выделяет небольшой фрагмент памяти, называемый фреймом стека. Фрейм содержит определенную важную информацию о текущем состоянии операторов обработки в функции, включая значения в любых переменных. Причина, по которой эта информация должна храниться в памяти (во фрейме), состоит в том, что функция может вызывать другую функцию, которая приостанавливает текущую функцию. Когда другая функция заканчивается, движку необходимо восстановить точное состояние с момента его приостановки.

Когда начинается второй вызов функции, ему также нужен фрейм, в результате чего счетчик фреймов становится равен 2. Если эта функция вызывает другую, нам нужен третий фрейм и так далее. Слово «стэк» говорит о том, что каждый раз, когда функция вызывается из предыдущей, следующий фрейм укладывается (или "стэкается") сверху. Когда вызов функции заканчивается, его фрейм выпадает из стека.

Рассмотрим программу:

```javascript
function foo() {
    var z = "foo!";
}

function bar() {
    var y = "bar!";
    foo();
}

function baz() {
    var x = "baz!";
    bar();
}

baz();
```

Визуализируем "настэкивание" фреймов этой программы:

[!stackFrames](https://raw.githubusercontent.com/getify/Functional-Light-JS/master/manuscript/images/fig15.png)

**Примечение:** Если эти функции не будут вызывать друг друга, а просто вызываться последовательно - `baz(); bar(); foo();`, где каждый вызов завершится раньше, чем начнется следующий - то "настэкивание" не будет происходить. Вызов функции завершается и удаляет фрейм из стэка прежде, чем добавится следующий.

Ок, для каждого вызова функции необходим маленький кусочек памяти. Это не имеет большого значения в нормальных условиях программы, верно? Но это быстро становится большой проблемой, как только вы используете рекурсию. Хотя вы почти наверняка никогда не ставите тысячи (или даже сотни!) Вызовов разных функций вместе в одном стеке вызовов, вы легко сможете увидеть десятки тысяч или более рекурсивных вызовов.

Взаимный вызов `isOdd(..)`/`isEven(..)` выдает `RangeError`, потому что движок имеет опеределленный лимит, и когда стек вырастает очень сильно, то работа должна быть прекращена. Лимит отражает не актуальное потребление памяти, а скорее некое предвидение движка: если эта программа продолжит работать, то неминуема утечка памяти. t is impossible to know or prove that a program will eventually stop, so the engine has to make an informed guess.

Этот лимит зависит от реализации. В спецификации об этом ничего не говорится, да это в общем-то и _не требуется_. Но практически все движки JS имеют лимит, потому что отсутствие онного, создает приложение, восприимчивое к "кривому" или плохонаписанному коду. Каждый движок в каждой другой среде будет применять свои собственные ограничения, нет другой возможности предсказать или гарантировать, как сильно мы можем увеличить стек вызовов.

Этот предел означает для нас, как разработчиков, то, что существует практическое ограничение применения рекурсии при решении задач на нетривиальных наборах данных. Я думаю, что это ограничение является главнейшей причиной того, что рекурсия - это "инстурмент второго сорта". К сожалению, рекурсия - это запоздалая мысль, а не первичная техника.


#### Tail Calls

Рекурсия появилась задолого до JS. Еще в 1960-х годах разработчики хотели использовать рекурсию и сталкивались с жесткими ограничениями памяти  на своих мощных компьютерах, которые были намного ниже, чем у наших часов сегодня.

К счастью, в те дни было сделано большое наблюдение, которое все еще дает надежду. Это - хвостовые вызовы.

Идея состоит в том, если вызов `bar` из `baz` происходит в самом конце выполнения `baz` (или в хвосте), то стек вызовов для `baz` не нужен вовсе.
Это означает, что либо память может быть восстановлена, либо даже лучше, просто повторно использована для обработки выполнения `bar`. Это выглядит так:

[!stackFrames](https://github.com/getify/Functional-Light-JS/blob/master/manuscript/images/fig16.png)

Хвостовые вызовы на самом деле не связаны напрямую с рекурсией; это понятие справедливо для любого вызова функции. **Но ваши ручные столы вызовов без рекурсии вряд ли превысят, возможно, 10 уровней в глубину в большинстве случаев, поэтому шансы на хвостовые звонки, влияющие на объем памяти вашей программы, довольно низки.**

**Хвостовой вызвов становится жемчужиной в случае рекурсии, потому что это означает, что рекурсивный стек может работать «навсегда», и единственная проблема с производительностью - это вычисление, а не ограничения фиксированной памяти. Tail call recursion can run in O(1) fixed memory usage.**

Эти техники часто называют - оптимизациями хвостовых вызовов (TCO) **but it's important to distinguish the ability to detect a tail call to run in fixed memory space, from the techniques that optimize this approach.** Технический, хвостовый вызовы сами по себе не являются оптимизацией, как многие думают. Более того, хвостовые вызовы могут работать медленнее обычных. TCO это как раз об оптимизациях.

#### Proper Tail Calls

JS никогда не требовал (и не зарпещал) использования хвостовых вызовов, до ES6. ES6 обечпечивает механихм использования хвостовых вызовов, также именуемый как "Чистые хвостовые вызовы"(PTC). РСТ гарантирует, что код, будет исполнятся без увеличения размера стека. Иными словами, используя РТС, вы не получите RangeError.

Во-первых РСТ в JS требует использования 'strict mode'. Вы уже должны были использовать 'strict mode', если вы еще не использовали его, то пора сделать это.

Во-вторых, _чистый_ хвостовой вызов выглядит так:

```javascript
return foo( .. );
```

Другими словами, вызов функции это последняя вещь, которую выполнит родительская функция, и результат выполнения будет явно возвращен. В этом случае JS дает абсолютную гарантию того, что текущий стек нам не понабодится.

Это _не_ хвостовые вызовы:

```javascript
foo();
return;

// или

var x = foo( .. );
return x;

// или

return 1 + foo( .. );
```

**Примечание**: Движок JS или умный транспилятор _может_ некоторые преобразования для `var x = foo( .. ); return x;` , которые так же эффективны, как и `return foo()` , и могут быть использованы для PTC. Но такое поведение необязательно с точки зрения спицификации.

Часть `1 + ` была обработана _после_ `foo()`, поэтому для этой операции необходимо поддержтвать стек.

Однака вот это уже РТС:

```javascript
return x ? foo( .. ) : bar( .. );
```

Когда условие `x` будет достигнуто, то выполнится или `foo()` или `bar()`, и в обоих случаях нам вернется результат. Это РТС.

Бинарная (или множественная) рекурсия не может оптимизирована с помощью РТС, потому что сама рекурсия должна находится в хвосте, чтобы избежать переполнения стека. По факту только один рекурсивный вызов, может находится в позиции, подходящей для РТС.

Ранее мы показывали пример рефактора бинарной во взаимную. Это делает возможным РСТ, путем отхода от мультирекурсивоного алгоритма и вынесения каждой рекурсии в отдельную функцию. Однако этот прием весьма запутанный и зависит от конктерного случая и выходит за рамки того, что мы изучаем в этой главе.

#### Перемещение рекурсии

Если вы хотите использовать рекурсию, но при этом есь вероятность переполнения стека JS-движка, вам нужно изменить порядок рекурсивных вызовов, чтобы воспользоваться преимуществами PTC (или полностью исключить вложенные вызовы). На этот случай сушествует несколько путей рефакторинга, но также следует упомянуть о существующих альтернативах.

На всякий случай напоминаю, что читаемость кода является нашей самой важной целью. Если рекурсия наряду с некоторой комбинацией описанных здесь стратегий приводит к тому, что код, становится сложнее для понимания, то *не используйте рекурсию*; найдите другое решение.

##### Replacing the Stack

Основная проблема рекурсии это потебление памяти в результате хранении стека вызова функции. Если мы сможем выяснить, как изменить порядок использования рекурсии, чтобы стек не требовался, то мы можем выразить рекурсию через PTC и воспользоваться оптимизациями хвостовых вызовов в движке JS.

Вспомним пример суммирования:

```javascript
function sum(num1,...nums) {
    if (nums.length == 0) return num1;
    return num1 + sum( ...nums );
}
```

Это еще не PTC форма, потому что после вызова `sum(...nums)` выполняется сложение. Для этого нужно сохранять стек.

Ключевым моментом рефакторинга является то, что мы могли бы избавиться от зависимости зависимости от стека, выполнив сложение _сейчас_ , а не _потом_, а затем передать результат сложения в рекурсивный вызов. Другими словами, вместо сохраниния результата в текущем стеке, мы переместим его в следующий стек рекурсивного вызова; это делает возможным удаление текущего стека.

Для начала изменим сигнатуру функции `sum()`, передав в нее новый параметр:

```javascript
function sum(result,num1,...nums) {
    // ..
}
```

Теперь вычислим результат сложения `result` и `num1`, и передадим его дальше:

```javascript
"use strict";

function sum(result,num1,...nums) {
    result = result + num1;
    if (nums.length == 0) return result;
    return sum( result, ...nums );
}
```

Теперь `sum()` это РТС, ура!

У этого спсобо есть недостаток, мы теперь изменили сигнатуру функции, которая усложняет ее использование. По сути, вызывающий должен всегда передавать `0` первым аргументом, чтобы суммирование работало:

```javascript
sum( /*initialResult=*/0, 3, 1, 17, 94, 8 );        // 123

```

Не очень хорошо.

Как правило, люди решают это, добавлением новой функции, которая скрывает все потроха:

```javascript
"use strict";

function sumRec(result,num1,...nums) {
    result = result + num1;
    if (nums.length == 0) return result;
    return sumRec( result, ...nums );
}

function sum(...nums) {
    return sumRec( /*initialResult=*/0, ...nums );
}

sum( 3, 1, 17, 94, 8 );// 123
```

Это лучше, но по-прежнему плохо. Мы создаем несколько функций вместо одной. Иногда можно встретить вот такое решение:

```javascript
"use strict";

function sum(...nums) {
    return sumRec( /*initialResult=*/0, ...nums );

    function sumRec(result,num1,...nums) {
        result = result + num1;
        if (nums.length == 0) return result;
        return sumRec( result, ...nums );
    }
}

sum( 3, 1, 17, 94, 8 );
```

Тут недостаток в том, что мы пересоздаем `sumRec()`, каждый раз когда вызывается `sum()`. Можно прокачать этот прием с помощью IIFE:

```javascript
"use strict";

var sum = (function IIFE(){

    return function sum(...nums) {
        return sumRec( /*initialResult=*/0, ...nums );
    }

    function sumRec(result,num1,...nums) {
        result = result + num1;
        if (nums.length == 0) return result;
        return sumRec( result, ...nums );
    }

})();

sum( 3, 1, 17, 94, 8 );                             // 123
```

Отлично, мы получили PTC и улучшили сигнатуру функции `sum()`, ура!

Но... теперь наша простая рекурсиваня функция иммет много мусора. Читаемость определенно ухудшилась. Нехорошо.

К счстью есть решение, давайте вернемся в прошлой версии:

```javascript
"use strict";

function sum(result,num1,...nums) {
    result = result + num1;
    if (nums.length == 0) return result;
    return sum( result, ...nums );
}

sum( /*initialResult=*/0, 3, 1, 17, 94, 8 );        // 123
```

**What you might observe is that result is a number just like num1, which means that we can always treat the first number in our list as our running total; that includes even the first call. All we need is to rename those params to make this clear:**

```javascript
"use strict";

function sum(num1,num2,...nums) {
    num1 = num1 + num2;
    if (nums.length == 0) return num1;
    return sum( num1, ...nums );
}

sum( 3, 1, 17, 94, 8 );                             // 123
```

Потрясающие. Это намного лучше, да !? Я думаю, что этот шаблон обеспечивает хороший баланс между качеством и перфомансом.

Попробуем провести рефактор методом PTC для функции `maxEven()`, которую мы рассмотривали ранее. **We'll observe that similar to keeping the sum as the first argument, we can narrow the list of numbers one at a time, keeping the first argument as the highest even we've come across thus far.**

Для ясности опишем алгоритм, который мы могли бы тут использовать:

1. Начнем со сравнения `num1` и `num2`
2. `num1` четное и больше `num2`? Значит сохраняем `num1`
3. ДОПИСАТЬ

```javascript
"use strict";

function maxEven(num1,num2,...nums) {
    num1 =
        (num1 % 2 == 0 && !(maxEven( num2 ) > num1)) ?
            num1 :
            (num2 % 2 == 0 ? num2 : undefined);

    return nums.length == 0 ?
        num1 :
        maxEven( num1, ...nums )
}
```

**Примечание**: первый вызов `maxEven()` не находится в позиции для РТС but because it only passes in num2, it only recurses just that one level then returns right back out; this is only a trick to avoid repeating the % logic. Таким образом, этот вызов не будет увеличивать рост рекурсивного стека, как если бы этот вызов был полностью другой функцией. Второй `maxEven()` это уже настоящий рекурсивный вызов, и находящийся в позиции для PTC, это означает, что стек не будет расти по мере того, как рекурсия будет продлжаться.

Следует повторить, что этот пример является лишь иллюстрацией подхода к приведению рекурсии к форме PTC для оптимизации использования стека (памяти).
Более правильный способ выразить алгоритм max-even может быть фильтрацией списка `nums` для для получения всех четных чисел, а затем испоьзования сортировки для получения максимального числа.

**Refactoring recursion into PTC is admittedly a little intrusive on the simple declarative form, but it still gets the job done reasonably. Unfortunately, some kinds of recursion won't work well even with an interface function, so we'll need different strategies.**

#### Стиль передачи продолжения (CPS)

Под _продолжением_  в JS чатсо подразумевается колбэк, который должен выполнится после того, как текущая функцию будет выполнена. Стркутура кода при которой функция получает функцию для выполнения в конце называется _стилем передачи продолжения (далее по тексту CSP, от англ. "Continuation Passing Style")_.

Некоторые формы рекурсии не могут быть преобразованный в PTC, особенно мультирекурсии. Вспоним  `fib()` и взаминую рекурсии, который мы рассматривали7 в обоих случаях. В обоих случаях там используется мультирекурсия, которая нарушает PTC.

Тем не менее, вы можете выполнить первый рекурсивный вызов и перенести последующие рекурсивные вызовы в функцию _продолжения_, передаваемую в первый вызов. Хотя это и означает, что в стеке должны выполнится гораздо больше функций, все из них, добавленные в виде продолжения, находятся в форме PTC, использование памяти стеком не будет расти.

Мы можем применить этот прием для `fib()`:

```javascript
"use strict";

function fib(n,cont = identity) {
    if (n <= 1) return cont( n );
    return fib(
        n - 2,
        n2 => fib(
            n - 1,
            n1 => cont( n2 + n1 )
        )
    );
}
```

Обратите особое внимание на то, что происходит здесь. Во-первых мы задаем дефолтное значение для функции _продолжения_ `cont()` в виде утилиты identity из [Главы 3](https://github.com/getify/Functional-Light-JS/blob/master/manuscript/ch3.md/#one-on-one); эта утилита просто возвращает то, что ей передали.

Кроме того добавлены еще (помимо cont) две функции _продолжения_. Первая получает аргумент `n2`, который в конечном итоге принимает значение, вычесленное в `fib(n-2)`. Следующее _продолжение_ принимает аргумент `n1`, который в итоге примет значение `fib(n-1)`. Когда значения `n2` и `n1` будут известны, они сложатся, и результат сложения будет передан в слудеющее _продолжение_ `cont()`.

Возможно, это поможет мысленно разобраться в том, что происходит: как и в предыдущем случае, когда мы передавали частичные результаты, а не возвращали их сразу, мы делаем то же самое здесь, но каждый шаг заключается в _продолжение_, котороре откладывает его вычисление. Этот трюк позволяет нам выполнять несколько вызовов, каждый из которых находится в форме PTC.

В статичечких языках CPS предоставляет возможность для хвостоввых вызовов, которые в свою очередь автоматически иддентифицируются компилятром и преобразуются для получения преимуществ. К сожалению, это не относится к JS.

В JavaScript вам, скорее всего, нужно будет написать форму CPS самостоятельно. Но в целом эта форма еще все более декларативная, чем реализация for-loop.

**Внимание:** Нужно дать одно предостережение, касательно CPS. В CPS создание _продолжений_ по-прежнему потребляет память, но немного для других целей. Потреблеие растет не за счет увеличения стека, а за счет работы замыканий. В этом случае движок не использует лимиты для `RangeError`, но это не означает, что использование вашей памяти не будет увеличиваться.

#### Трамплины

Другая техника для уменьшения поьребления памяти это _трамплины_. Так же как и CPS этот стиль подразумевает создание _продолжений_, но вместо их передачи, происходит их возврат, с учетом неглубокой вложенности.

Глубина стека никогда не выходит на пределы одного, потому что каждая функция просто возвращает следующую функцию, которая должна быть вызвана. Цикл просто запускает каждую возвращаемую функцию до тех пор, пока не останется функций для вызова.

Одним из преимуществ траиплинов является то, что вы не ограничены окружениями, поддерживающими PTC; другой заключается в том, что каждый вызов функции является регулярным, а не оптимизированным по PTC, поэтому такой способ может работать быстрее.

Как может выглядеть утилита трамплина:

```javascript
function trampoline(fn) {
    return function trampolined(...args) {
        var result = fn( ...args );

        while (typeof result == "function") {
            result = result();
        }

        return result;
    };
}
```

Пока функция возвращается, цикл продолжает работать, проверяя тип возвращаемого знаения. Как только вернется "не функция", трамплин предполагает, что вызов функции завершен и просто возвращает значение.

Поскольку каждое продолжение должно возвращать другое продолжение, нам нужно использовать уже знакомый трюк для передачи частичного результата в качестве аргумента. Вот как мы можем использовать эту утилиту в функции суммирования чисел:

```javascript
var sum = trampoline(
    function sum(num1,num2,...nums) {
        num1 = num1 + num2;
        if (nums.length == 0) return num1;
        return () => sum( num1, ...nums );
    }
);

var xs = [];
for (let i=0; i<20000; i++) {
    xs.push( i );
}

sum( ...xs ); // 199990000
```

Недостатком является то, требуется обернуть рекурсивную функцию в _трамплин_. Кроме того, как и CPS, для каждого продолжения создаются замыкания. Однако, в отличие от CPS, каждая функция продолжения возвращается и завершается сразу, поэтому движку не нужно увеличивать выделение памяти на этот процесс, что решает проблему растущего стека.

Помимо производительности и производительности памяти преимущество трамплинов над CPS заключается в том, что вам не нужно менять сигнатуру функции для получения аргумента функции продолжения. Трамплины не идеальны, но они могут быть эффективным балансом между императивным циклом и декларативной рекурсией.

### Заключение

Рекурсия - это когда функция рекурсивно вызывает себя. Хех. Рекурсивное определение рекурсии. Что за!?

Прямая рекурсия - это функция, которая делает по крайней мере один самовызов, и он продолжает вызывать себя, пока не удовлетворит базовое условие. Множественная рекурсия (например, бинарная рекурсия) - это когда функция вызывает себя несколько раз. Взаимная рекурсия - это когда две или более функции рекурсивно _взаимно_ вызывают друг друга.

Преимущество рекурсии состоит в том, что она более декларативная и, следовательно, обычно более читабельная. Недостатком обычно является производительность, но в части использования памяти, а не скорости выполнения.

Хвостовые вызовы уменьшают потребление памяти, путем сброса стека. JavaScript требует "strict mode" и PTC, для того, чтобы воспользоваться оптимизациями хвостовых вызовов. Существует несоколько техник преобразования рекурсивных функций в форму PTC.

Помните: рекурсия должна использоваться, чтобы сделать код более читаемым. Если вы  злоупотреьите рекурсией, читаемость окажется хуже, чем императивная форма. Не делай этого!
